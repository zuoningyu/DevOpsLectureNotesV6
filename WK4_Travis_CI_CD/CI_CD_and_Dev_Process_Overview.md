# CI CD n Dev Process Overview

## Development process from a Dev perspective

## I) Before coding

### 1. Plan the journey

Create a Jira __Epic__ to define the scope of the work that you plan to accomplish.

Try to break down the epic as much as possible into __Tasks__, step by step for the work.

Create task tickets to track each step.

The tasks can be a __feature development__, __add tests__, __writing docs__, or even __investigate the tech stack__
can be a ticket. The point here is to be as specific as possible.

During a weekly meeting, the team plan out which __tasks__ to be moved into the following __Sprint__ (Typically 10
business days)
![Alt text](images/Start_a_Sprint.png?raw=true)

The team should use story points to estimate the work.
Typically for a feature development, it should take no more 8 hours/story points;
In most cases, it should be controlled with in 3 hours.
https://www.atlassian.com/agile/project-management/estimation
The ideas is to have small incremental changes, so the team can be agile

So, before you start coding, you should already have all the plans/tasks created on your Jira software board.
![Alt text](images/Sprint_board.png?raw=true)

### 2. Clone/Create the repo when you start a new project
```
git clone <repo>
```

### 3. Branch off the development branch
To avoid conflict with your colleagues, checkout your code to a different branch.
```
git checkout -b issue/<Jira Ticket Key>-<New_Branch_Name>
```
You can also do this via Jira ticket -> create branch (Note: configuration may be needed)

## II) Start coding
![Alt text](images/Ticket_in_Progress.png?raw=true)

### 0.Make sure your IDE is ready
Of course, you should make sure your IDE is setup properly. IDE helps you do auto formatting for a specific language
and has many other useful features.

However, you should know the basic rules about when you use capital/camel case etc.. for interview purpose.

### 1. (First-time only) Install Dependencies and Setup the Project
Python:
```
pip install -r requirements.txt
```

Node:
```
npm install
```

Java:
```
mvn install
```

What other language can you think of?

### 2. Write Test
Test Driven is important for quality of the code. We recommend developers write tests first.
* What is the expected input?
* What is the expected output?

### 3. Write Code
Because the amount of work of a ticket is very small with clear definition of done, the developer can finish writing the
working version within a few hours.

### 4. Add Monitoring
It is always a good move to add monitoring around your feature, so that you gain visibility when the code is in
production.

For example:
* Log the error/exceptions of your code
* Monitor the latency of a function

Some critical funcs may also need extra monitoring, but they can be tracked in a separate ticket:
* Monitor CPU/Memory/Disk Usage
* Implement a /healthcheck and configure Nginx/ALB to auto hit this endpoint every 5 seconds
* Log the request count, error count, status code and monitor the error rates


## III) After coding
### 1.Validate

Double check what has been committed.
```
git status
git diff
```

### 2.Commit the code

After commit and push the code, a PR link will be autogenerated and popped.

```
git add <files> 
git add -u
git commit  
git push
```
### 3. CI tests should be triggered
The CI tests will automatically build and test your code on a configurable agent server.

The idea is that if you write some buggy code, they should be captured early without affecting the team.

#### What can the CI pipeline help with?

* Code Linter/ Auto Formatter

* Syntax Checker

* Run Unit-test/Integration Test automatically and show the results

Many add-ons/tools can be used and we will cover it in later chapters


### 4. Find peers to review the PR
Find Subject Matter Expert (SME) to review your PR and provide feedbacks. You should discuss and try to resolve them.

#### What you can do as a developer:

* clearly write down the description and link to the Jira issue

* make sure you have good test coverage for your code

* make sure all builds are green

* ask peers to review and comment; fix issues and push changes recommended by peers.

### 5. Merge the PR 
once the PR is approved, you are good to merge.


## What is CI?
Continuous integration (CI) is the practice of frequently building and testing each change done to your code
automatically and as early as possible.


## Why CI ?
The whole point of CI is to have everyone working on a known stable base.

![Alt text](images/CI_DEV.png?raw=true)

Using CI, you’ll spend less time:

* Worrying about introducing a bug every time you make changes
* Fixing the mess someone else made so you can integrate your code
* Making sure the code works on every machine, operating system, and browser

![Alt text](images/CI_BUILD_TEST_SUCCESS.png?raw=true)

Conversely, you’ll spend more time:

* Solving interesting problems
* Writing awesome code with your team
* Co-creating amazing products that provide value to users

Ref: https://realpython.com/python-continuous-integration/#single-source-repository

## What CD pipeline can help with?
![Alt text](images/CI_DEV_PROD.png?raw=true)
Continuously delivery of the feature that developers wrote to production (customers).
We can use CD Pipeline to:
* Do Canary Deployment/Run Internal Test
* Run Integration Test/Regression Test/Performance Test etc...
* If issues identified, rollback before having customer impact

### 1.Wait for dev/staging deployment kicks off

Typically, in CI/CD pipeline, the staging branch will fast forward to master which should trigger the staging deployment

If everything is going well with staging deployment, there will be another few hours for soaking.

Engineers can take this opportunity to do more tests on staging environment and monitor the staging environment

### 2.Wait for prod deployment kicks off

Once the soak is done and all tests passed, the prod deployment will kick off.

Keep an eye on the monitors to make sure nothing is saturated.


## Post Deployment/Production Operation - things to do after the CI/CD

Once the code reach the production environment, the real challenge will arise. In production environment, the system 
has a more complex setup, dependencies and many moving parts. In general, in a software lifecycle, software development
only takes up to 20% of total cost (work/time/money etc...), but operation can eat up to 80%. 

Things/Questions often need to consider:

* [Deployment] How do we make sure the App have zero downtime during deployment?
* [Deployment] To reduce the blast of radius that can caused by an incident, what deployment strategy do we need to
  apply?
* [Monitoring & Alerting] How do we know if our software is not working as expected in production? How can we know where
  the bottleneck is?
* [Monitoring & Alerting] Which dashboards to check when problem occurs? How to read the dashboards?
* [Monitoring & Alerting] I don't wanna watch the monitors, which key metrics should we alert on?  
* [Capacity Management] Is our scaling policy set correctly(e.g. can handle the traffic load and also not too expensive)?
* [Operation] How to recycle the nodes without affecting customers?  
* [Operation] How do we rollback if there is a problem? and how fast can we rollback?
* [Operation] How do we recover fast/reduce Mean Time To Recover (MTTR) when there is a disaster/incident(e.g. one 
  server is down)?

## Responsibilities

### What are Devs responsibilities?
* Write the code for the project and write its unit-tests
* Add metrics/logs in the code to monitor the critical changes
* Dockerise existing repo with DevOps


### What are DevOps responsibilities?
* Dockerise existing repo with Devs
* Setup CI/CD pipeline
* Come up with Integration/System Testing/End-to-end testing plan
* Setup monitoring system for the Pipelines
* Setup automated rollback and blockers

### What are SRE responsibilities?
* Solving post deployment operational problems
* Improve the monitoring dashboards and alerts
* Tuning system parameters
* Develop software tools to automate operational steps
* Facilitate incident mitigation and investigation


## Tests in the CI/CD

Before you submit for code review by peers, make sure that you have created some tests to test your code

Also, please make sure you have the CI pipeline to auto run the tests.

What are the common tests

![Alt text](images/test_basics.jpg?raw=true)

### 1.Unittest

Unit tests test individual components, it can be as small as a function.

Unit tests are very low level, close to the source of your application. They consist in testing individual methods
and functions of the classes, components or modules used by your software. Unit tests are in general quite cheap to
automate and can be run very quickly by a continuous integration server.


![Alt text](images/function.jpg?raw=true)

In python, you can run the test like this:

```
python -m unittest tests/test_something.py
```

### 2.Integration Test

Integration Test is a level of software testing where individual units are combined and tested as a group.

For example, if you have a controller with REST APIs which is connected back to your database, sending REST requests to
the controller would be considered as integration test. You may use curl to call an endpoint like this:
```
curl --header "Content-Type: application/json" \
  --request POST \
  --data '{"username":"xyz","password":"xyz"}' \
  http://localhost:3000/api/login
```

### 3.Performance/System Testing

Load Testing - is necessary to know that a software solution will perform under real-life loads. Gatling/Locust

### 4.Acceptance/End-to-end Testing

User Acceptance Testing (UAT) is a type of testing performed by the end user or the client to verify/accept the
software system before moving the software application to the production environment.

Automation Test - blackbox monitoring from the customer perspective. Webdriver/Cypress

Reference: https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing













